<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head profile="http://dublincore.org/documents/2008/08/04/dc-html/"> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <meta name="robots" content="index,follow" /> 
  <meta name="creator" content="rfcmarkup version 1.127" /> 
  <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" /> 
  <meta name="DC.Relation.Replaces" content="draft-shafer-netmod-arch" /> 
  <meta name="DC.Identifier" content="urn:ietf:rfc:6244" /> 
  <meta name="DC.Date.Issued" content="June, 2011" /> 
  <meta name="DC.Creator" content="Phil Shafer &lt;phil@juniper.net&gt;" /> 
  <meta name="DC.Description.Abstract" content="NETCONF gives access to native capabilities of the devices within a
network, defining methods for manipulating configuration databases,
retrieving operational data, and invoking specific operations. YANG
provides the means to define the content carried via NETCONF, both
data and operations. Using both technologies, standard modules can be
defined to give interoperability and commonality to devices, while
still allowing devices to express their unique capabilities.  This
document describes how NETCONF and YANG help build network management
applications that meet the needs of network operators." /> 
  <meta name="DC.Title" content="An Architecture for Network Management Using NETCONF and YANG" /> 
  <link rel="icon" href="/images/rfc.png" type="image/png" /> 
  <link rel="shortcut icon" href="/images/rfc.png" type="image/png" /> 
  <title>RFC 6244 - An Architecture for Network Management Using NETCONF and YANG</title> 
  <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style> 
  <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]--> 
  <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script> 
 </head> 
 <body onload="addHeaderTags()"> 
  <div class="content"> 
   <div style="height: 13px;"> 
    <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute;" class="pre noprint docinfo bgorange" title="Click for colour legend."> 
    </div> 
    <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');"> 
    </div> 
   </div> 
   <span class="pre noprint docinfo top">[<a href="https://tools.ietf.org/html/" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6244.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6244" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-netmod-arch" title="draft-ietf-netmod-arch">draft-ietf-netm...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6244" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6244" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6244" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6244">Errata</a>]</span>
   <br /> 
   <span class="pre noprint docinfo"> </span>
   <br /> 
   <span class="pre noprint docinfo"> INFORMATIONAL</span>
   <br /> 
   <span class="pre noprint docinfo"> <span style="color: #C00;">Errata Exist</span></span>
   <br /> 
   <pre>Internet Engineering Task Force (IETF)                         P. Shafer
Request for Comments: 6244                              Juniper Networks
Category: Informational                                        June 2011
ISSN: 2070-1721


     <span class="h1"><h1>An Architecture for Network Management Using NETCONF and YANG</h1></span>

Abstract

   The Network Configuration Protocol (NETCONF) gives access to native
   capabilities of the devices within a network, defining methods for
   manipulating configuration databases, retrieving operational data,
   and invoking specific operations.  YANG provides the means to define
   the content carried via NETCONF, both data and operations.  Using
   both technologies, standard modules can be defined to give
   interoperability and commonality to devices, while still allowing
   devices to express their unique capabilities.

   This document describes how NETCONF and YANG help build network
   management applications that meet the needs of network operators.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="https://tools.ietf.org/html/rfc5741#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6244">http://www.rfc-editor.org/info/rfc6244</a>.














<span class="grey">Shafer                        Informational                     [Page 1]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-2" id="page-2" href="https://tools.ietf.org/html/rfc6244#page-2" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























<span class="grey">Shafer                        Informational                     [Page 2]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-3" id="page-3" href="https://tools.ietf.org/html/rfc6244#page-3" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


Table of Contents

   <a href="https://tools.ietf.org/html/rfc6244#section-1">1</a>.  Origins of NETCONF and YANG  . . . . . . . . . . . . . . . . .  <a href="https://tools.ietf.org/html/rfc6244#page-4">4</a>
   <a href="https://tools.ietf.org/html/rfc6244#section-2">2</a>.  Elements of the Architecture . . . . . . . . . . . . . . . . .  <a href="https://tools.ietf.org/html/rfc6244#page-5">5</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-2.1">2.1</a>.  NETCONF  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="https://tools.ietf.org/html/rfc6244#page-5">5</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-2.1.1">2.1.1</a>.  NETCONF Transport Mappings . . . . . . . . . . . . . .  <a href="https://tools.ietf.org/html/rfc6244#page-7">7</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-2.2">2.2</a>.  YANG . . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="https://tools.ietf.org/html/rfc6244#page-8">8</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-2.2.1">2.2.1</a>.  Constraints  . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-10">10</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-2.2.2">2.2.2</a>.  Flexibility  . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-11">11</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-2.2.3">2.2.3</a>.  Extensibility Model  . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-12">12</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-2.3">2.3</a>.  YANG Translations  . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-13">13</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-2.3.1">2.3.1</a>.  YIN  . . . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-13">13</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-2.3.2">2.3.2</a>.  DSDL (RELAX NG)  . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-14">14</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-2.4">2.4</a>.  YANG Types . . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-14">14</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-2.5">2.5</a>.  IETF Guidelines  . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-14">14</a>
   <a href="https://tools.ietf.org/html/rfc6244#section-3">3</a>.  Working with YANG  . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-14">14</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-3.1">3.1</a>.  Building NETCONF- and YANG-Based Solutions . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-14">14</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-3.2">3.2</a>.  Addressing Operator Requirements . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-16">16</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-3.3">3.3</a>.  Roles in Building Solutions  . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-18">18</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-3.3.1">3.3.1</a>.  Modeler  . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-19">19</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-3.3.2">3.3.2</a>.  Reviewer . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-19">19</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-3.3.3">3.3.3</a>.  Device Developer . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-19">19</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-3.3.4">3.3.4</a>.  Application Developer  . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-20">20</a>
   <a href="https://tools.ietf.org/html/rfc6244#section-4">4</a>.  Modeling Considerations  . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-22">22</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-4.1">4.1</a>.  Default Values . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-22">22</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-4.2">4.2</a>.  Compliance . . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-23">23</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-4.3">4.3</a>.  Data Distinctions  . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-24">24</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-4.3.1">4.3.1</a>.  Background . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-24">24</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-4.3.2">4.3.2</a>.  Definitions  . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-25">25</a>
       <a href="https://tools.ietf.org/html/rfc6244#section-4.3.3">4.3.3</a>.  Implications . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-27">27</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-4.4">4.4</a>.  Direction  . . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-27">27</a>
   <a href="https://tools.ietf.org/html/rfc6244#section-5">5</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-28">28</a>
   <a href="https://tools.ietf.org/html/rfc6244#section-6">6</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-28">28</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-6.1">6.1</a>.  Normative References . . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-28">28</a>
     <a href="https://tools.ietf.org/html/rfc6244#section-6.2">6.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="https://tools.ietf.org/html/rfc6244#page-29">29</a>
















<span class="grey">Shafer                        Informational                     [Page 3]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-4" id="page-4" href="https://tools.ietf.org/html/rfc6244#page-4" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h2"><h2><a class="selflink" name="section-1" href="https://tools.ietf.org/html/rfc6244#section-1">1</a>. Origins of NETCONF and YANG</h2></span>

   Networks are increasing in complexity and capacity, as well as the
   density of the services deployed upon them.  Uptime, reliability, and
   predictable latency requirements drive the need for automation.  The
   problems with network management are not simple.  They are complex
   and intricate.  But these problems must be solved for networks to
   meet the stability needs of existing services while incorporating new
   services in a world where the growth of networks is exhausting the
   supply of qualified networking engineers.

   In June of 2002, the Internet Architecture Board (IAB) held a
   workshop on Network Management [<a href="https://tools.ietf.org/html/rfc3535" title="&quot;Overview of the 2002 IAB Network Management Workshop&quot;">RFC3535</a>].  The members of this
   workshop made a number of observations and recommendations for the
   IETF's consideration concerning the issues operators were facing in
   their network management-related work as well as issues they were
   having with the direction of the IETF activities in this area.

   The output of this workshop was focused on current problems.  The
   observations were reasonable and straightforward, including the need
   for transactions, rollback, low implementation costs, and the ability
   to save and restore the device's configuration data.  Many of the
   observations give insight into the problems operators were having
   with existing network management solutions, such as the lack of full
   coverage of device capabilities and the ability to distinguish
   between configuration data and other types of data.

   Based on these directions, the NETCONF working group was formed and
   the Network Configuration (NETCONF) protocol was created.  This
   protocol defines a simple mechanism where network management
   applications, acting as clients, can invoke operations on the
   devices, which act as servers.  The NETCONF specification [<a href="https://tools.ietf.org/html/rfc4741" title="&quot;NETCONF Configuration Protocol&quot;">RFC4741</a>]
   defines a small set of operations, but goes out of its way to avoid
   making any requirements on the data carried in those operations,
   preferring to allow the protocol to carry any data.  This &quot;data model
   agnostic&quot; approach allows data models to be defined independently.

   But lacking a means of defining data models, the NETCONF protocol was
   not usable for standards-based work.  Existing data modeling
   languages such as the XML Schema Definition (XSD) [<a href="https://tools.ietf.org/html/rfc6244#ref-W3CXSD" title="&quot;XML Schema Part 0: Primer Second Edition&quot;">W3CXSD</a>] and the
   Document Schema Definition Languages (DSDL) [<a href="https://tools.ietf.org/html/rfc6244#ref-ISODSDL" title="&quot;Document Schema Definition Languages (DSDL) - Part 1: Overview&quot;">ISODSDL</a>] were
   considered, but were rejected because of the problem that domains
   have little natural overlap.  Defining a data model or protocol that
   is encoded in XML is a distinct problem from defining an XML
   document.  The use of NETCONF operations places requirements on the
   data content that are not shared with the static document problem
   domain addressed by schema languages like XSD or RELAX NG.




<span class="grey">Shafer                        Informational                     [Page 4]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-5" id="page-5" href="https://tools.ietf.org/html/rfc6244#page-5" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   In 2007 and 2008, the issue of a data modeling language for NETCONF
   was discussed in the OPS and APP areas of IETF 70 and 71, and a
   design team was tasked with creating a requirements document [<a href="https://tools.ietf.org/html/rfc6244#ref-RCDML" title="&quot;Requirements for a Configuration Data Modeling Language&quot;">RCDML</a>].
   After discussing the available options at the CANMOD BoF at IETF 71,
   the community wrote a charter for the NETMOD working group.  An
   excellent description of this time period is available at
   &lt;<a href="http://www.ietf.org/mail-archive/web/ietf/current/msg51644.html">http://www.ietf.org/mail-archive/web/ietf/current/msg51644.html</a>&gt;.

   In 2008 and 2009, the NETMOD working group produced a specification
   for YANG [<a href="https://tools.ietf.org/html/rfc6020" title="&quot;YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)&quot;">RFC6020</a>] as a means for defining data models for NETCONF,
   allowing both standard and proprietary data models to be published in
   a form that is easily digestible by human readers and satisfies many
   of the issues raised in the IAB NM workshop.  This brings NETCONF to
   a point where is can be used to develop standard data models within
   the IETF.

   YANG allows a modeler to create a data model, to define the
   organization of the data in that model, and to define constraints on
   that data.  Once published, the YANG module acts as a contract
   between the client and server, with both parties understanding how
   their peer will expect them to behave.  A client knows how to create
   valid data for the server, and knows what data will be sent from the
   server.  A server knows the rules that govern the data and how it
   should behave.

   YANG also incorporates a level of extensibility and flexibility not
   present in other model languages.  New modules can augment the data
   hierarchies defined in other modules, seamlessly adding data at
   appropriate places in the existing data organization.  YANG also
   allows new statements to be defined, allowing the language itself to
   be expanded in a consistent way.

   This document presents an architecture for YANG, describing how YANG-
   related technologies work and how solutions built on them can address
   the network management problem domain.

<span class="h2"><h2><a class="selflink" name="section-2" href="https://tools.ietf.org/html/rfc6244#section-2">2</a>. Elements of the Architecture</h2></span>

<span class="h3"><h3><a class="selflink" name="section-2.1" href="https://tools.ietf.org/html/rfc6244#section-2.1">2.1</a>. NETCONF</h3></span>

   NETCONF defines an XML-based remote procedure call (RPC) mechanism
   that leverages the simplicity and availability of high-quality XML
   parsers.  XML gives a rich, flexible, hierarchical, standard
   representation of data that matches the needs of networking devices.
   NETCONF carries configuration data and operations as requests and
   replies using RPCs encoded in XML over a connection-oriented
   transport.




<span class="grey">Shafer                        Informational                     [Page 5]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-6" id="page-6" href="https://tools.ietf.org/html/rfc6244#page-6" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   XML's hierarchical data representation allows complex networking data
   to be rendered in a natural way.  For example, the following
   configuration places interfaces in OSPF areas.  The &lt;ospf&gt; element
   contains a list of &lt;area&gt; elements, each of which contain a list of
   &lt;interface&gt; elements.  The &lt;name&gt; element identifies the specific
   area or interface.  Additional configuration for each area or
   interface appears directly inside the appropriate element.

         &lt;ospf xmlns=&quot;http://example.org/netconf/ospf&quot;&gt;

           &lt;area&gt;
             &lt;name&gt;0.0.0.0&lt;/name&gt;

             &lt;interface&gt;
               &lt;name&gt;ge-0/0/0.0&lt;/name&gt;
               &lt;!-- The priority for this interface --&gt;
               &lt;priority&gt;30&lt;/priority&gt;
               &lt;metric&gt;100&lt;/metric&gt;
               &lt;dead-interval&gt;120&lt;/dead-interval&gt;
             &lt;/interface&gt;

             &lt;interface&gt;
               &lt;name&gt;ge-0/0/1.0&lt;/name&gt;
               &lt;metric&gt;140&lt;/metric&gt;
             &lt;/interface&gt;
           &lt;/area&gt;

           &lt;area&gt;
             &lt;name&gt;10.1.2.0&lt;/name&gt;

             &lt;interface&gt;
               &lt;name&gt;ge-0/0/2.0&lt;/name&gt;
               &lt;metric&gt;100&lt;/metric&gt;
             &lt;/interface&gt;

             &lt;interface&gt;
               &lt;name&gt;ge-0/0/3.0&lt;/name&gt;
               &lt;metric&gt;140&lt;/metric&gt;
               &lt;dead-interval&gt;120&lt;/dead-interval&gt;
             &lt;/interface&gt;
           &lt;/area&gt;
         &lt;/ospf&gt;

   NETCONF includes mechanisms for controlling configuration datastores.
   Each datastore is a specific collection of configuration data that
   can be used as source or target of the configuration-related
   operations.  The device can indicate whether it has a distinct
   &quot;startup&quot; configuration datastore, whether the current or &quot;running&quot;



<span class="grey">Shafer                        Informational                     [Page 6]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-7" id="page-7" href="https://tools.ietf.org/html/rfc6244#page-7" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   datastore is directly writable, or whether there is a &quot;candidate&quot;
   configuration datastore where configuration changes can be made that
   will not affect the device until a &quot;commit-configuration&quot; operation
   is invoked.

   NETCONF defines operations that are invoked as RPCs from the client
   (the application) to the server (running on the device).  The
   following table lists some of these operations:

   +---------------+---------------------------------------------------+
   | Operation     | Description                                       |
   +---------------+---------------------------------------------------+
   | commit        | Commit the &quot;candidate&quot; configuration to &quot;running&quot; |
   | copy-config   | Copy one configuration datastore to another       |
   | delete-config | Delete a configuration datastore                  |
   | edit-config   | Change the contents of a configuration datastore  |
   | get-config    | Retrieve all or part of a configuration datastore |
   | lock          | Prevent changes to a datastore from another party |
   | unlock        | Release a lock on a datastore                     |
   +---------------+---------------------------------------------------+

   NETCONF's &quot;capability&quot; mechanism allows the device to announce the
   set of capabilities that the device supports, including protocol
   operations, datastores, data models, and other abilities.  These are
   announced during session establishment as part of the &lt;hello&gt;
   message.  A client can inspect the hello message to determine what
   the device is capable of and how to interact with the device to
   perform the desired tasks.

   NETCONF also defines a means of sending asynchronous notifications
   from the server to the client, described in [<a href="https://tools.ietf.org/html/rfc5277" title="&quot;NETCONF Event Notifications&quot;">RFC5277</a>].

   In addition, NETCONF can fetch state data, receive notifications, and
   invoke additional RPC methods defined as part of a capability.
   Complete information about NETCONF can be found in [<a href="https://tools.ietf.org/html/rfc4741" title="&quot;NETCONF Configuration Protocol&quot;">RFC4741</a>].

<span class="h4"><h4><a class="selflink" name="section-2.1.1" href="https://tools.ietf.org/html/rfc6244#section-2.1.1">2.1.1</a>. NETCONF Transport Mappings</h4></span>

   NETCONF can run over any transport protocol that meets the
   requirements defined in <a href="https://tools.ietf.org/html/rfc4741">RFC 4741</a>, including

   o  connection-oriented operation

   o  authentication

   o  integrity

   o  confidentiality



<span class="grey">Shafer                        Informational                     [Page 7]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-8" id="page-8" href="https://tools.ietf.org/html/rfc6244#page-8" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   [<a name="ref-RFC4742" id="ref-RFC4742">RFC4742</a>] defines a mapping for the Secure Shell (SSH) [<a href="https://tools.ietf.org/html/rfc4251" title="&quot;The Secure Shell (SSH) Protocol Architecture&quot;">RFC4251</a>]
   protocol, which is the mandatory transport protocol.  Others include
   SOAP [<a href="https://tools.ietf.org/html/rfc4743" title="&quot;Using NETCONF over the Simple Object Access Protocol (SOAP)&quot;">RFC4743</a>], the Blocks Extensible Exchange Protocol (BEEP)
   [<a href="https://tools.ietf.org/html/rfc4744" title="&quot;Using the NETCONF Protocol over the Blocks Extensible Exchange Protocol (BEEP)&quot;">RFC4744</a>], and Transport Layer Security (TLS) [<a href="https://tools.ietf.org/html/rfc5539" title="&quot;NETCONF over Transport Layer Security (TLS)&quot;">RFC5539</a>].

<span class="h3"><h3><a class="selflink" name="section-2.2" href="https://tools.ietf.org/html/rfc6244#section-2.2">2.2</a>. YANG</h3></span>

   YANG is a data modeling language for NETCONF.  It allows the
   description of hierarchies of data nodes (&quot;nodes&quot;) and the
   constraints that exist among them.  YANG defines data models and how
   to manipulate those models via NETCONF protocol operations.

   Each YANG module defines a data model, uniquely identified by a
   namespace URI.  These data models are extensible in a manner that
   allows tight integration of standard data models and proprietary data
   models.  Models are built from organizational containers, lists of
   data nodes, and data-node-forming leafs of the data tree.


































<span class="grey">Shafer                        Informational                     [Page 8]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-9" id="page-9" href="https://tools.ietf.org/html/rfc6244#page-9" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


       module example-ospf {
           namespace &quot;http://example.org/netconf/ospf&quot;;
           prefix ospf;

           import network-types {  // Access another module's def'ns
               prefix nett;
           }

           container ospf {   // Declare the top-level tag
               list area {    // Declare a list of &quot;area&quot; nodes
                   key name;  // The key &quot;name&quot; identifies list members
                   leaf name {
                       type nett:area-id;
                   }
                   list interface {
                       key name;
                       leaf name {
                           type nett:interface-name;
                       }
                       leaf priority {
                           description &quot;Designated router priority&quot;;
                           type uint8;  // The type is a constraint on
                                        // valid values for &quot;priority&quot;.
                       }
                       leaf metric {
                           type uint16 {
                               range 1..65535;
                           }
                       }
                       leaf dead-interval {
                           units seconds;
                           type uint16 {
                               range 1..65535;
                           }
                       }
                   }
               }
           }
       }

   A YANG module defines a data model in terms of the data, its
   hierarchical organization, and the constraints on that data.  YANG
   defines how this data is represented in XML and how that data is used
   in NETCONF operations.







<span class="grey">Shafer                        Informational                     [Page 9]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-10" id="page-10" href="https://tools.ietf.org/html/rfc6244#page-10" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   The following table briefly describes some common YANG statements:

   +--------------+----------------------------------------------------+
   | Statement    | Description                                        |
   +--------------+----------------------------------------------------+
   | augment      | Extends existing data hierarchies                  |
   | choice       | Defines mutually exclusive alternatives            |
   | container    | Defines a layer of the data hierarchy              |
   | extension    | Allows new statements to be added to YANG          |
   | feature      | Indicates parts of the model that are optional     |
   | grouping     | Groups data definitions into reusable sets         |
   | key          | Defines the key leafs for lists                    |
   | leaf         | Defines a leaf node in the data hierarchy          |
   | leaf-list    | A leaf node that can appear multiple times         |
   | list         | A hierarchy that can appear multiple times         |
   | notification | Defines notification                               |
   | rpc          | Defines input and output parameters for an RPC     |
   |              | operation                                          |
   | typedef      | Defines a new type                                 |
   | uses         | Incorporates the contents of a &quot;grouping&quot;          |
   +--------------+----------------------------------------------------+

<span class="h4"><h4><a class="selflink" name="section-2.2.1" href="https://tools.ietf.org/html/rfc6244#section-2.2.1">2.2.1</a>. Constraints</h4></span>

   YANG allows the modeler to add constraints to the data model to
   prevent impossible or illogical data.  These constraints give clients
   information about the data being sent from the device, and also allow
   the client to know as much as possible about the data the device will
   accept, so the client can send correct data.  These constraints apply
   to configuration data, but can also be used for rpc and notification
   data.

   The principal constraint is the &quot;type&quot; statement, which limits the
   contents of a leaf node to that of the named type.  The following
   table briefly describes some other common YANG constraints:
















<span class="grey">Shafer                        Informational                    [Page 10]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-11" id="page-11" href="https://tools.ietf.org/html/rfc6244#page-11" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   +--------------+----------------------------------------------------+
   | Statement    | Description                                        |
   +--------------+----------------------------------------------------+
   | length       | Limits the length of a string                      |
   | mandatory    | Requires the node appear                           |
   | max-elements | Limits the number of instances in a list           |
   | min-elements | Limits the number of instances in a list           |
   | must         | XPath expression must be true                      |
   | pattern      | Regular expression must be satisfied               |
   | range        | Value must appear in range                         |
   | reference    | Value must appear elsewhere in the data            |
   | unique       | Value must be unique within the data               |
   | when         | Node is only present when XPath expression is true |
   +--------------+----------------------------------------------------+

   The &quot;must&quot; and &quot;when&quot; statements use XPath [<a href="https://tools.ietf.org/html/rfc6244#ref-W3CXPATH" title="&quot;XML Path Language (XPath) Version 1.0&quot;">W3CXPATH</a>] expressions to
   specify conditions that are semantically evaluated against the data
   hierarchy, but neither the client nor the server are required to
   implement the XPath specification.  Instead they can use any means to
   ensure these conditions are met.

<span class="h4"><h4><a class="selflink" name="section-2.2.2" href="https://tools.ietf.org/html/rfc6244#section-2.2.2">2.2.2</a>. Flexibility</h4></span>

   YANG uses the &quot;union&quot; type and the &quot;choice&quot; and &quot;feature&quot; statements
   to give modelers flexibility in defining their data models.  The
   &quot;union&quot; type allows a single leaf to accept multiple types, like an
   integer or the word &quot;unbounded&quot;:

     type union {
         type int32;
         type enumeration {
             enum &quot;unbounded&quot;;
         }
     }

   The &quot;choice&quot; statement lists a set of mutually exclusive nodes, so a
   valid configuration can choose any one node (or case).  The &quot;feature&quot;
   statement allows the modeler to identify parts of the model that can
   be optional, and allows the device to indicate whether it implements
   these optional portions.

   The &quot;deviation&quot; statement allows the device to indicate parts of a
   YANG module that the device does not faithfully implement.  While
   devices are encouraged to fully abide according to the contract
   presented in the YANG module, real-world situations may force the
   device to break the contract.  Deviations give a means of declaring
   this limitation, rather than leaving it to be discovered via run-time
   errors.



<span class="grey">Shafer                        Informational                    [Page 11]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-12" id="page-12" href="https://tools.ietf.org/html/rfc6244#page-12" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h4"><h4><a class="selflink" name="section-2.2.3" href="https://tools.ietf.org/html/rfc6244#section-2.2.3">2.2.3</a>. Extensibility Model</h4></span>

   XML includes the concept of namespaces, allowing XML elements from
   different sources to be combined in the same hierarchy without
   risking collision.  YANG modules define content for specific
   namespaces, but one module may augment the definition of another
   module, introducing elements from that module's namespace into the
   first module's hierarchy.

   Since one module can augment another module's definition, hierarchies
   of definitions are allowed to grow, as definitions from multiple
   sources are added to the base hierarchy.  These augmentations are
   qualified using the namespace of the source module, helping to avoid
   issues with name conflicts as the modules change over time.

   For example, if the above OSPF configuration were the standard, a
   vendor module may augment this with vendor-specific extensions.

       module vendorx-ospf {
           namespace &quot;http://vendorx.example.com/ospf&quot;;
           prefix vendorx;

           import example-ospf {
               prefix ospf;
           }

           augment /ospf:ospf/ospf:area/ospf:interfaces {
               leaf no-neighbor-down-notification {
                   type empty;
                   description &quot;Don't inform other protocols about&quot;
                             + &quot; neighbor down events&quot;;
               }
           }
       }

   The &lt;no-neighbor-down-notification&gt; element is then placed in the
   vendorx namespace:














<span class="grey">Shafer                        Informational                    [Page 12]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-13" id="page-13" href="https://tools.ietf.org/html/rfc6244#page-13" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


       &lt;ospf xmlns=&quot;http://example.org/netconf/ospf&quot;
             xmlns:vendorx=&quot;http://vendorx.example.com/ospf&quot;&gt;

         &lt;area&gt;
           &lt;name&gt;0.0.0.0&lt;/name&gt;

           &lt;interface&gt;
             &lt;name&gt;ge-0/0/0.0&lt;/name&gt;
             &lt;priority&gt;30&lt;/priority&gt;
             &lt;vendorx:no-neighbor-down-notification/&gt;
           &lt;/interface&gt;

         &lt;/area&gt;
       &lt;/ospf&gt;

   Augmentations are seamlessly integrated with base modules, allowing
   them to be fetched, archived, loaded, and deleted within their
   natural hierarchy.  If a client application asks for the
   configuration for a specific OSPF area, it will receive the sub-
   hierarchy for that area, complete with any augmented data.

<span class="h3"><h3><a class="selflink" name="section-2.3" href="https://tools.ietf.org/html/rfc6244#section-2.3">2.3</a>. YANG Translations</h3></span>

   The YANG data modeling language is the central piece of a group of
   related technologies.  The YANG language itself, described in
   [<a href="https://tools.ietf.org/html/rfc6020" title="&quot;YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)&quot;">RFC6020</a>], defines the syntax of the language and its statements, the
   meaning of those statements, and how to combine them to build the
   hierarchy of nodes that describe a data model.

   That document also defines the &quot;on the wire&quot; XML content for NETCONF
   operations on data models defined in YANG modules.  This includes the
   basic mapping between YANG data tree nodes and XML elements, as well
   as mechanisms used in &lt;edit-config&gt; content to manipulate that data,
   such as arranging the order of nodes within a list.

   YANG uses a syntax that is regular and easily described, primarily
   designed for human readability.  YANG's syntax is friendly to email,
   diff, patch, and the constraints of RFC formatting.

<span class="h4"><h4><a class="selflink" name="section-2.3.1" href="https://tools.ietf.org/html/rfc6244#section-2.3.1">2.3.1</a>. YIN</h4></span>

   In some environments, incorporating a YANG parser may not be an
   acceptable option.  For those scenarios, an XML grammar for YANG is
   defined as YIN (YANG Independent Notation).  YIN allows the use of
   XML parsers that are readily available in both open source and
   commercial versions.  Conversion between YANG and YIN is direct,
   loss-less, and reversible.  YANG statements are converted to XML
   elements, preserving the structure and content of YANG, but enabling



<span class="grey">Shafer                        Informational                    [Page 13]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-14" id="page-14" href="https://tools.ietf.org/html/rfc6244#page-14" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   the use of off-the-shelf XML parsers rather than requiring the
   integration of a YANG parser.  YIN maintains complete semantic
   equivalence with YANG.

<span class="h4"><h4><a class="selflink" name="section-2.3.2" href="https://tools.ietf.org/html/rfc6244#section-2.3.2">2.3.2</a>. DSDL (RELAX NG)</h4></span>

   Since NETCONF content is encoded in XML, it is natural to use XML
   schema languages for their validation.  To facilitate this, YANG
   offers a standardized mapping of YANG modules into Document Schema
   Definition Languages [<a href="https://tools.ietf.org/html/rfc6110" title="&quot;Mapping YANG to Document Schema Definition Languages and Validating NETCONF Content&quot;">RFC6110</a>], of which RELAX NG is a major
   component.

   DSDL is considered to be the best choice as a standard schema
   language because it addresses not only grammar and datatypes of XML
   documents but also semantic constraints and rules for modifying the
   information set of the document.

   In addition, DSDL offers formal means for coordinating multiple
   independent schemas and specifying how to apply the schemas to the
   various parts of the document.  This is useful since YANG content is
   typically composed of multiple vocabularies.

<span class="h3"><h3><a class="selflink" name="section-2.4" href="https://tools.ietf.org/html/rfc6244#section-2.4">2.4</a>. YANG Types</h3></span>

   YANG supports a number of builtin types, and allows additional types
   to be derived from those types in an extensible manner.  New types
   can add additional restrictions to allowable data values.

   A standard type library for use by YANG is available [<a href="https://tools.ietf.org/html/rfc6021" title="&quot;Common YANG Data Types&quot;">RFC6021</a>].
   These YANG modules define commonly used data types for IETF-related
   standards.

<span class="h3"><h3><a class="selflink" name="section-2.5" href="https://tools.ietf.org/html/rfc6244#section-2.5">2.5</a>. IETF Guidelines</h3></span>

   A set of additional guidelines is defined that indicate desirable
   usage for authors and reviewers of Standards-Track specifications
   containing YANG data model modules [<a href="https://tools.ietf.org/html/rfc6087" title="&quot;Guidelines for Authors and Reviewers of YANG Data Model Documents&quot;">RFC6087</a>].  These guidelines
   should be used as a basis for reviews of other YANG data model
   documents.

<span class="h2"><h2><a class="selflink" name="section-3" href="https://tools.ietf.org/html/rfc6244#section-3">3</a>. Working with YANG</h2></span>

<span class="h3"><h3><a class="selflink" name="section-3.1" href="https://tools.ietf.org/html/rfc6244#section-3.1">3.1</a>. Building NETCONF- and YANG-Based Solutions</h3></span>

   In the typical YANG-based solution, the client and server are driven
   by the content of YANG modules.  The server includes the definitions
   of the modules as meta-data that is available to the NETCONF engine.
   This engine processes incoming requests, uses the meta-data to parse



<span class="grey">Shafer                        Informational                    [Page 14]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-15" id="page-15" href="https://tools.ietf.org/html/rfc6244#page-15" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   and verify the request, performs the requested operation, and returns
   the results to the client.

                       +----------------------------+
                       |Server (device)             |
                       |    +--------------------+  |
                       |    |      configuration |  |
            +----+     |    |     ---------------|  |
            |YANG|+    |    | m d  state data    |  |
            |mods||+   |    | e a ---------------|  |
            +----+|| -----&gt; | t t  notifications |  |
             +----+|   |    | a a ---------------|  |
              +----+   |    |      operations    |  |
                       |    +--------------------+  |
                       |           ^                |
                       |           |                |
                       |           v                |
     +------+          |     +-------------+        |
     |      | -------------&gt; |             |        |
     |Client| &lt;rpc&gt;    |     |  NETCONF    |        |
     | (app)|          |     |   engine    |        |
     |      | &lt;------------  |             |        |
     +------+ &lt;rpc-reply&gt;    +-------------+        |
                       |       /        \           |
                       |      /          \          |
                       |     /            \         |
                       | +--------+   +---------+   |
                       | | config |   |system   |+  |
                       | |  data- |   |software ||+ |
                       | |   base |   |component||| |
                       | +--------+   +---------+|| |
                       |               +---------+| |
                       |                +---------+ |
                       +----------------------------+

   To use YANG, YANG modules must be defined to model the specific
   problem domain.  These modules are then loaded, compiled, or coded
   into the server.

   The sequence of events for the typical client/server interaction may
   be as follows:

   o  A client application ([C]) opens a NETCONF session to the server
      (device) ([S])

   o  [C] and [S] exchange &lt;hello&gt; messages containing the list of
      capabilities supported by each side, allowing [C] to learn the
      modules supported by [S]



<span class="grey">Shafer                        Informational                    [Page 15]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-16" id="page-16" href="https://tools.ietf.org/html/rfc6244#page-16" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   o  [C] builds and sends an operation defined in the YANG module,
      encoded in XML, within NETCONF's &lt;rpc&gt; element

   o  [S] receives and parses the &lt;rpc&gt; element

   o  [S] verifies the contents of the request against the data model
      defined in the YANG module

   o  [S] performs the requested operation, possibly changing the
      configuration datastore

   o  [S] builds the response, containing the response, any requested
      data, and any errors

   o  [S] sends the response, encoded in XML, within NETCONF's
      &lt;rpc-reply&gt; element

   o  [C] receives and parses the &lt;rpc-reply&gt; element

   o  [C] inspects the response and processes it as needed

   Note that there is no requirement for the client or server to process
   the YANG modules in this way.  The server may hard code the contents
   of the data model, rather than handle the content via a generic
   engine.  Or the client may be targeted at the specific YANG model,
   rather than being driven generically.  Such a client might be a
   simple shell script that stuffs arguments into an XML payload
   template and sends it to the server.

<span class="h3"><h3><a class="selflink" name="section-3.2" href="https://tools.ietf.org/html/rfc6244#section-3.2">3.2</a>. Addressing Operator Requirements</h3></span>

   NETCONF and YANG address many of the issues raised in the IAB NM
   workshop.

   o  Ease of use: YANG is designed to be human friendly, simple, and
      readable.  Many tricky issues remain due to the complexity of the
      problem domain, but YANG strives to make them more visible and
      easier to deal with.

   o  Configuration and state data: YANG clearly divides configuration
      data from other types of data.

   o  Transactions: NETCONF provides a simple transaction mechanism.

   o  Generation of deltas: A YANG module gives enough information to
      generate the delta needed to change between two configuration data
      sets.




<span class="grey">Shafer                        Informational                    [Page 16]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-17" id="page-17" href="https://tools.ietf.org/html/rfc6244#page-17" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   o  Dump and restore: NETCONF gives the ability to save and restore
      configuration data.  This can also be performed for a specific
      YANG module.

   o  Network-wide configuration: NETCONF supports robust network-wide
      configuration transactions via the commit and confirmed-commit
      capabilities.  When a change is attempted that affects multiple
      devices, these capabilities simplify the management of failure
      scenarios, resulting in the ability to have transactions that will
      dependably succeed or fail atomically.

   o  Text-friendly: YANG modules are very text friendly, as is the data
      they define.

   o  Configuration handling: NETCONF addresses the ability to
      distinguish between distributing configuration data and activating
      it.

   o  Task-oriented: A YANG module can define specific tasks as RPC
      operations.  A client can choose to invoke the RPC operation or to
      access any underlying data directly.

   o  Full coverage: YANG modules can be defined that give full coverage
      to all the native abilities of the device.  Giving this access
      avoids the need to resort to the command line interface (CLI)
      using tools such as Expect [<a href="https://tools.ietf.org/html/rfc6244#ref-SWEXPECT" title="&quot;The Expect Home Page&quot;">SWEXPECT</a>].

   o  Timeliness: YANG modules can be tied to CLI operations, so all
      native operations and data are immediately available.

   o  Implementation difficulty: YANG's flexibility enables modules that
      can be more easily implemented.  Adding &quot;features&quot; and replacing
      &quot;third normal form&quot; with a natural data hierarchy should reduce
      complexity.

   o  Simple data modeling language: YANG has sufficient power to be
      usable in other situations.  In particular, on-box API and native
      CLI can be integrated to achieve simplification of the
      infrastructure.

   o  Internationalization: YANG uses UTF-8 [<a href="https://tools.ietf.org/html/rfc3629" title="&quot;UTF-8, a transformation format of ISO 10646&quot;">RFC3629</a>] encoded Unicode
      characters.

   o  Event correlation: YANG integrates RPC operations, notification,
      configuration, and state data, enabling internal references.  For
      example, a field in a notification can be tagged as pointing to a
      BGP peer, and the client application can easily find that peer in
      the configuration data.



<span class="grey">Shafer                        Informational                    [Page 17]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-18" id="page-18" href="https://tools.ietf.org/html/rfc6244#page-18" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   o  Implementation costs: Significant effort has been made to keep
      implementation costs as low as possible.

   o  Human-friendly syntax: YANG's syntax is optimized for the reader,
      specifically the reviewer on the basis that this is the most
      common human interaction.

   o  Post-processing: Use of XML will maximize the opportunities for
      post-processing of data, possibly using XML-based technologies
      like XPath [<a href="https://tools.ietf.org/html/rfc6244#ref-W3CXPATH" title="&quot;XML Path Language (XPath) Version 1.0&quot;">W3CXPATH</a>], XQuery [<a href="https://tools.ietf.org/html/rfc6244#ref-W3CXQUERY" title="&quot;XQuery 1.0: An XML Query Language&quot;">W3CXQUERY</a>], and XSLT [<a href="https://tools.ietf.org/html/rfc6244#ref-W3CXSLT" title="&quot;XSL Transformations (XSLT) Version 1.0&quot;">W3CXSLT</a>].

   o  Semantic mismatch: Richer, more descriptive data models will
      reduce the possibility of semantic mismatch.  With the ability to
      define new primitives, YANG modules will be more specific in
      content, allowing more enforcement of rules and constraints.

   o  Security: NETCONF runs over transport protocols secured by SSH or
      TLS, allowing secure communications and authentication using well-
      trusted technology.  The secure transport can use existing key and
      credential management infrastructure, reducing deployment costs.

   o  Reliable: NETCONF and YANG are solid and reliable technologies.
      NETCONF is connection based, and includes automatic recovery
      mechanisms when the connection is lost.

   o  Delta friendly: YANG-based models support operations that are
      delta friendly.  Add, change, insert, and delete operations are
      all well defined.

   o  Method-oriented: YANG allows new RPC operations to be defined,
      including an operation name, which is essentially a method.  The
      input and output parameters of the RPC operations are also defined
      in the YANG module.

<span class="h3"><h3><a class="selflink" name="section-3.3" href="https://tools.ietf.org/html/rfc6244#section-3.3">3.3</a>. Roles in Building Solutions</h3></span>

   Building NETCONF- and YANG-based solutions requires interacting with
   many distinct groups.  Modelers must understand how to build useful
   models that give structure and meaning to data while maximizing the
   flexibility of that data to &quot;future proof&quot; their work.  Reviewers
   need to quickly determine if that structure is accurate.  Device
   developers need to code that data model into their devices, and
   application developers need to code their applications to take
   advantage of that data model.  There are a variety of strategies for
   performing each piece of this work.  This section discusses some of
   those strategies.





<span class="grey">Shafer                        Informational                    [Page 18]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-19" id="page-19" href="https://tools.ietf.org/html/rfc6244#page-19" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h4"><h4><a class="selflink" name="section-3.3.1" href="https://tools.ietf.org/html/rfc6244#section-3.3.1">3.3.1</a>. Modeler</h4></span>

   The modeler defines a data model based on their in-depth knowledge of
   the problem domain being modeled.  This model should be as simple as
   possible, but should balance complexity with expressiveness.  The
   organization of the model not only should target the current model
   but also should allow for extensibility from other modules and for
   adaptability to future changes.

   Additional modeling issues are discussed in <a href="https://tools.ietf.org/html/rfc6244#section-4">Section 4</a>.

<span class="h4"><h4><a class="selflink" name="section-3.3.2" href="https://tools.ietf.org/html/rfc6244#section-3.3.2">3.3.2</a>. Reviewer</h4></span>

   The reviewer role is perhaps the most important and the time
   reviewers are willing to give is precious.  To help the reviewer,
   YANG stresses readability, with a human-friendly syntax, natural data
   hierarchy, and simple, concise statements.

<span class="h4"><h4><a class="selflink" name="section-3.3.3" href="https://tools.ietf.org/html/rfc6244#section-3.3.3">3.3.3</a>. Device Developer</h4></span>

   The YANG model tells the device developer what data is being modeled.
   The developer reads the YANG models and writes code that supports the
   model.  The model describes the data hierarchy and associated
   constraints, and the description and reference material helps the
   developer understand how to transform the model's view into the
   device's native implementation.

<span class="h5"><h5><a class="selflink" name="section-3.3.3.1" href="https://tools.ietf.org/html/rfc6244#section-3.3.3.1">3.3.3.1</a>. Generic Content Support</h5></span>

   The YANG model can be compiled into a YANG-based engine for either
   the client or server side.  Incoming data can be validated, as can
   outgoing data.  The complete configuration datastore may be validated
   in accordance with the constraints described in the data model.

   Serializers and de-serializers for generating and receiving NETCONF
   content can be driven by the meta-data in the model.  As data is
   received, the meta-data is consulted to ensure the validity of
   incoming XML elements.

<span class="h5"><h5><a class="selflink" name="section-3.3.3.2" href="https://tools.ietf.org/html/rfc6244#section-3.3.3.2">3.3.3.2</a>. XML Definitions</h5></span>

   The YANG module dictates the XML encoding for data sent via NETCONF.
   The rules that define the encoding are fixed, so the YANG module can
   be used to ascertain whether a specific NETCONF payload is obeying
   the rules.






<span class="grey">Shafer                        Informational                    [Page 19]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-20" id="page-20" href="https://tools.ietf.org/html/rfc6244#page-20" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h4"><h4><a class="selflink" name="section-3.3.4" href="https://tools.ietf.org/html/rfc6244#section-3.3.4">3.3.4</a>. Application Developer</h4></span>

   The YANG module tells the application developer what data can be
   modeled.  Developers can inspect the modules and take one of three
   distinct views.  In this section, we will consider them and the
   impact of YANG on their design.  In the real world, most applications
   are a mixture of these approaches.

<span class="h5"><h5><a class="selflink" name="section-3.3.4.1" href="https://tools.ietf.org/html/rfc6244#section-3.3.4.1">3.3.4.1</a>. Hard Coded</h5></span>

   An application can be coded against the specific, well-known contents
   of YANG modules, implementing their organization, rules, and logic
   directly with explicit knowledge.  For example, a script could be
   written to change the domain name of a set of devices using a
   standard YANG module that includes such a leaf node.  This script
   takes the new domain name as an argument and inserts it into a string
   containing the rest of the XML encoding as required by the YANG
   module.  This content is then sent via NETCONF to each of the
   devices.

   This type of application is useful for small, fixed problems where
   the cost and complexity of flexibility are overwhelmed by the ease of
   hard coding direct knowledge into the application.

<span class="h5"><h5><a class="selflink" name="section-3.3.4.2" href="https://tools.ietf.org/html/rfc6244#section-3.3.4.2">3.3.4.2</a>. Bottom Up</h5></span>

   An application may take a generic, bottom-up approach to
   configuration, concentrating on the device's data directly and
   treating that data without specific understanding.

   YANG modules may be used to drive the operation of the YANG
   equivalent of a &quot;MIB browser&quot;.  Such an application manipulates the
   device's configuration data based on the data organization contained
   in the YANG module.  For example, a GUI may present a straightforward
   visualization where elements of the YANG hierarchy are depicted in a
   hierarchy of folders or GUI panels.  Clicking on a line expands to
   the contents of the matching XML hierarchy.

   This type of GUI can easily be built by generating XSLT stylesheets
   from the YANG data models.  An XSLT engine can then be used to turn
   configuration data into a set of web pages.

   The YANG modules allow the application to enforce a set of
   constraints without understanding the semantics of the YANG module.







<span class="grey">Shafer                        Informational                    [Page 20]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-21" id="page-21" href="https://tools.ietf.org/html/rfc6244#page-21" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h5"><h5><a class="selflink" name="section-3.3.4.3" href="https://tools.ietf.org/html/rfc6244#section-3.3.4.3">3.3.4.3</a>. Top Down</h5></span>

   In contrast to the bottom-up approach, the top-down approach allows
   the application to take a view of the configuration data that is
   distinct from the standard and/or proprietary YANG modules.  The
   application is free to construct its own model for data organization
   and to present this model to the user.  When the application needs to
   transmit data to a device, the application transforms its data from
   the problem-oriented view of the world into the data needed for that
   particular device.  This transformation is under the control and
   maintenance of the application, allowing the transformation to be
   changed and updated without affecting the device.

   For example, an application could be written that models VPNs in a
   network-oriented view.  The application would need to transform these
   high-level VPN definitions into the configuration data that would be
   handed to any particular device within a VPN.

   Even in this approach, YANG is useful since it can be used to model
   the VPN.  For example, the following VPN straw-man models a list of
   VPNs, each with a protocol, a topology, a list of member interfaces,
   and a list of classifiers.

       list example-bgpvpn {
           key name;
           leaf name { ... }
           leaf protocol {
               type enumeration {
                   enum bgpvpn;
                   enum l2vpn;
               }
           }
           leaf topology {
               type enumeration {
                   enum hub-n-spoke;
                   enum mesh;
               }
           }
           list members {
               key &quot;device interface&quot;;
               leaf device { ... }
               leaf interface { ... }
           }
           list classifiers {
               ...
           }
       }




<span class="grey">Shafer                        Informational                    [Page 21]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-22" id="page-22" href="https://tools.ietf.org/html/rfc6244#page-22" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   The application can use such a YANG module to drive its operation,
   building VPN instances in a database and then pushing the
   configuration for those VPNs to individual devices either using a
   standard device model (e.g., example-bgpvpn.yang) or by transforming
   that standard device content into some proprietary format for devices
   that do not support that standard.

<span class="h2"><h2><a class="selflink" name="section-4" href="https://tools.ietf.org/html/rfc6244#section-4">4</a>. Modeling Considerations</h2></span>

   This section discusses considerations the modeler should be aware of
   while developing models in YANG.

<span class="h3"><h3><a class="selflink" name="section-4.1" href="https://tools.ietf.org/html/rfc6244#section-4.1">4.1</a>. Default Values</h3></span>

   The concept of default values is simple, but their details,
   representation, and interaction with configuration data can be
   difficult issues.  NETCONF leaves default values as a data model
   issue, and YANG gives flexibility to the device implementation in
   terms of how default values are handled.  The requirement is that the
   device &quot;MUST operationally behave as if the leaf was present in the
   data tree with the default value as its value&quot;.  This gives the
   device implementation choices in how default values are handled.

   One choice is to view the configuration as a set of instructions for
   how the device should be configured.  If a data value that is given
   as part of those instructions is the default value, then it should be
   retained as part of the configuration, but if it is not explicitly
   given, then the value is not considered to be part of the
   configuration.

   Another choice is to trim values that are identical to the default
   values, implicitly removing them from the configuration datastore.
   The act of setting a leaf to its default value effectively deletes
   that leaf.

   The device could also choose to report all default values, regardless
   of whether they were explicitly set.  This choice eases the work of a
   client that needs default values, but may significantly increase the
   size of the configuration data.

   These choices reflect the default handling schemes of widely deployed
   networking devices and supporting them allows YANG to reduce
   implementation and deployment costs of YANG-based models.








<span class="grey">Shafer                        Informational                    [Page 22]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-23" id="page-23" href="https://tools.ietf.org/html/rfc6244#page-23" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   When the client retrieves data from the device, it must be prepared
   to handle the absence of leaf nodes with the default value, since the
   server is not required to send such leaf elements.  This permits the
   device to implement either of the first two default handling schemes
   given above.

   Regardless of the implementation choice, the device can support the
   &quot;with-defaults&quot; capability [<a href="https://tools.ietf.org/html/rfc6243" title="&quot;With-defaults Capability for NETCONF&quot;">RFC6243</a>] and give the client the ability
   to select the desired handling of default values.

   When evaluating the XPath expressions for constraints like &quot;must&quot; and
   &quot;when&quot;, the evaluation context for the expressions will include any
   appropriate default values, so the modeler can depend on consistent
   behavior from all devices.

<span class="h3"><h3><a class="selflink" name="section-4.2" href="https://tools.ietf.org/html/rfc6244#section-4.2">4.2</a>. Compliance</h3></span>

   In developing good data models, there are many conflicting interests
   the data modeler must keep in mind.  Modelers need to be aware of
   five issues with models and devices:

   o  usefulness

   o  compliance

   o  flexibility

   o  extensibility

   o  deviations

   For a model to be interesting, it must be useful, solving a problem
   in a more direct or more powerful way than can be accomplished
   without the model.  The model should maximize the usefulness of the
   model within the problem domain.

   Modelers should build models that maximize the number of devices that
   can faithfully implement the model.  If the model is drawn too
   narrowly, or includes too many assumptions about the device, then the
   difficulty and cost of accurately implementing the model will lead to
   low-quality implementations and interoperability issues, and will
   reduce the value of the model.

   Modelers can use the &quot;feature&quot; statement in their models to give the
   device some flexibility by partitioning their model and allowing the
   device to indicate which portions of the model are implemented on the





<span class="grey">Shafer                        Informational                    [Page 23]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-24" id="page-24" href="https://tools.ietf.org/html/rfc6244#page-24" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   device.  For example, if the model includes some &quot;logging&quot; feature, a
   device with no storage facilities for the log can tell the client
   that it does not support this feature of the model.

   Models can be extended via the &quot;augment&quot; statement, and the modeler
   should consider how their model is likely to be extended.  These
   augmentations can be defined by vendors, applications, or standards
   bodies.

   Deviations are a means of allowing the devices to indicate where its
   implementation is not in full compliance with the model.  For
   example, once a model is published, an implementer may decide to make
   a particular node configurable, where the standard model describes it
   as state data.  The implementation reports the value normally and may
   declare a deviation that this device behaves in a different manner
   than the standard.  Applications capable of discovering this
   deviation can make allowances, but applications that do not discover
   the deviation can continue treating the implementation as if it were
   compliant.

   Rarely, implementations may make decisions that prevent compliance
   with the standard.  Such occasions are regrettable, but they remain a
   part of reality, and modelers and application writers ignore them at
   their own risk.  An implementation that emits an integer leaf as
   &quot;cow&quot; would be difficult to manage, but applications should expect to
   encounter such misbehaving devices in the field.

   Despite this, both client and server should view the YANG module as a
   contract, with both sides agreeing to abide by the terms.  The
   modeler should be explicit about the terms of such a contract, and
   both client and server implementations should strive to faithfully
   and accurately implement the data model described in the YANG module.

<span class="h3"><h3><a class="selflink" name="section-4.3" href="https://tools.ietf.org/html/rfc6244#section-4.3">4.3</a>. Data Distinctions</h3></span>

   The distinction between configuration data, operational state data,
   and statistics is important to understand for data model writers and
   people who plan to extend the NETCONF protocol.  This section first
   discusses some background and then provides a definition and some
   examples.

<span class="h4"><h4><a class="selflink" name="section-4.3.1" href="https://tools.ietf.org/html/rfc6244#section-4.3.1">4.3.1</a>. Background</h4></span>

   During the IAB NM workshop, operators did formulate the following two
   requirements, as listed in [<a href="https://tools.ietf.org/html/rfc3535" title="&quot;Overview of the 2002 IAB Network Management Workshop&quot;">RFC3535</a>]:






<span class="grey">Shafer                        Informational                    [Page 24]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-25" id="page-25" href="https://tools.ietf.org/html/rfc6244#page-25" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


    2.  It is necessary to make a clear distinction between
        configuration data, data that describes operational state,
        and statistics.  Some devices make it very hard to determine
        which parameters were administratively configured and which
        were obtained via other mechanisms such as routing
        protocols.

    3.  It is required to be able to fetch separately configuration
        data, operational state data, and statistics from devices,
        and to be able to compare these between devices.

   The NETCONF protocol defined in <a href="https://tools.ietf.org/html/rfc4741">RFC 4741</a> distinguishes two types of
   data -- namely, configuration data and state data:

      Configuration data is the set of writable data that is
      required to transform a system from its initial default state
      into its current state.

      State data is the additional data on a system that is not
      configuration data such as read-only status information and
      collected statistics.

   NETCONF does not follow the distinction formulated by the operators
   between configuration data, operational state data, and statistical
   data, since it considers state data to include both statistics and
   operational state data.

<span class="h4"><h4><a class="selflink" name="section-4.3.2" href="https://tools.ietf.org/html/rfc6244#section-4.3.2">4.3.2</a>. Definitions</h4></span>

   Below is a definition for configuration data, operational state data,
   and statistical data.  The definition borrows from previous work.

   o  Configuration data is the set of writable data that is required to
      transform a system from its initial default state into its current
      state [<a href="https://tools.ietf.org/html/rfc4741" title="&quot;NETCONF Configuration Protocol&quot;">RFC4741</a>].

   o  Operational state data is a set of data that has been obtained by
      the system at runtime and influences the system's behavior similar
      to configuration data.  In contrast to configuration data,
      operational state is transient and modified by interactions with
      internal components or other systems via specialized protocols.

   o  Statistical data is the set of read-only data created by a system
      itself.  It describes the performance of the system and its
      components.

   The following examples help to clarify the difference between
   configuration data, operational state data, and statistical data.



<span class="grey">Shafer                        Informational                    [Page 25]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-26" id="page-26" href="https://tools.ietf.org/html/rfc6244#page-26" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h5"><h5><a class="selflink" name="section-4.3.2.1" href="https://tools.ietf.org/html/rfc6244#section-4.3.2.1">4.3.2.1</a>. Example 1: IP Routing Table</h5></span>

   IP routing tables can contain entries that are statically configured
   (configuration data) as well as entries obtained from routing
   protocols such as OSPF (operational state data).  In addition, a
   routing engine might collect statistics like how often a particular
   routing table entry has been used.

<span class="h5"><h5><a class="selflink" name="section-4.3.2.2" href="https://tools.ietf.org/html/rfc6244#section-4.3.2.2">4.3.2.2</a>. Example 2: Interfaces</h5></span>

   Network interfaces usually come with a large number of attributes
   that are specific to the interface type and in some cases specific to
   the cable plugged into an interface.  Examples are the maximum
   transmission unit of an interface or the speed detected by an
   Ethernet interface.

   In many deployments, systems use the interface attributes detected
   when an interface is initialized.  As such, these attributes
   constitute operational state.  However, there are usually provisions
   to overwrite the discovered attributes with static configuration
   data, like for example configuring the interface MTU to use a
   specific value or forcing an Ethernet interface to run at a given
   speed.

   The system will record statistics (counters) measuring the number of
   packets, bytes, and errors received and transmitted on each
   interface.

<span class="h5"><h5><a class="selflink" name="section-4.3.2.3" href="https://tools.ietf.org/html/rfc6244#section-4.3.2.3">4.3.2.3</a>. Example 3: Account Information</h5></span>

   Systems usually maintain static configuration information about the
   accounts on the system.  In addition, systems can obtain information
   about accounts from other sources (e.g., Lightweight Directory Access
   Protocol (LDAP), Network Information Service (NIS)) dynamically,
   leading to operational state data.  Information about account usage
   is an example of statistical data.

   Note that configuration data supplied to a system in order to create
   a new account might be supplemented with additional configuration
   information determined by the system when the account is being
   created (such as a unique account id).  Even though the system might
   create such information, it usually becomes part of the static
   configuration of the system since this data is not transient.








<span class="grey">Shafer                        Informational                    [Page 26]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-27" id="page-27" href="https://tools.ietf.org/html/rfc6244#page-27" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


<span class="h4"><h4><a class="selflink" name="section-4.3.3" href="https://tools.ietf.org/html/rfc6244#section-4.3.3">4.3.3</a>. Implications</h4></span>

   The primary focus of YANG is configuration data.  There is no single
   mechanism defined for the separation of operational state data and
   statistics since NETCONF treats them both as state data.  This
   section describes several different options for addressing this
   issue.

<span class="h5"><h5><a class="selflink" name="section-4.3.3.1" href="https://tools.ietf.org/html/rfc6244#section-4.3.3.1">4.3.3.1</a>. Data Models</h5></span>

   The first option is to have data models that explicitly differentiate
   between configuration data and operational state data.  This leads to
   duplication of data structures and might not scale well from a
   modeling perspective.

   For example, the configured duplex value and the operational duplex
   value would be distinct leafs in the data model.

<span class="h5"><h5><a class="selflink" name="section-4.3.3.2" href="https://tools.ietf.org/html/rfc6244#section-4.3.3.2">4.3.3.2</a>. Additional Operations to Retrieve Operational State</h5></span>

   The NETCONF protocol can be extended with new protocol operations
   that specifically allow the retrieval of all operational state, e.g.,
   by introducing a &lt;get-ops&gt; operation (and perhaps also a &lt;get-stats&gt;
   operation).

<span class="h5"><h5><a class="selflink" name="section-4.3.3.3" href="https://tools.ietf.org/html/rfc6244#section-4.3.3.3">4.3.3.3</a>. Introduction of an Operational State Datastore</h5></span>

   Another option could be to introduce a new &quot;configuration&quot; data store
   that represents the operational state.  A &lt;get-config&gt; operation on
   the &lt;operational&gt; data store would then return the operational state
   determining the behavior of the box instead of its static and
   explicit configuration state.

<span class="h3"><h3><a class="selflink" name="section-4.4" href="https://tools.ietf.org/html/rfc6244#section-4.4">4.4</a>. Direction</h3></span>

   At this time, the only viable solution is to distinctly model the
   configuration and operational values.  The configuration leaf would
   indicate the desired value, as given by the user, and the operational
   leaf would indicate the current value, as observed on the device.

   In the duplex example, this would result in two distinct leafs being
   defined, &quot;duplex&quot; and &quot;op-duplex&quot;, one with &quot;config true&quot; and one
   with &quot;config false&quot;.








<span class="grey">Shafer                        Informational                    [Page 27]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-28" id="page-28" href="https://tools.ietf.org/html/rfc6244#page-28" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   In some cases, distinct leafs would be used, but in others, distinct
   lists might be used.  Distinct lists allows the list to be organized
   in different ways, with different constraints.  Keys, sorting, and
   constraint statements like must, unique, or when may differ between
   configuration data and operational data.

   For example, configured static routes might be a distinct list from
   the operational routing table, since the use of keys and sorting
   might differ.

<span class="h2"><h2><a class="selflink" name="section-5" href="https://tools.ietf.org/html/rfc6244#section-5">5</a>. Security Considerations</h2></span>

   This document discusses an architecture for network management using
   NETCONF and YANG.  It has no security impact on the Internet.

<span class="h2"><h2><a class="selflink" name="section-6" href="https://tools.ietf.org/html/rfc6244#section-6">6</a>. References</h2></span>

<span class="h3"><h3><a class="selflink" name="section-6.1" href="https://tools.ietf.org/html/rfc6244#section-6.1">6.1</a>. Normative References</h3></span>

   [<a name="ref-ISODSDL" id="ref-ISODSDL">ISODSDL</a>]    International Organization for Standardization,
                &quot;Document Schema Definition Languages (DSDL) - Part 1:
                Overview&quot;, ISO/IEC 19757-1, November 2004.

   [<a name="ref-RFC3535" id="ref-RFC3535">RFC3535</a>]    Schoenwaelder, J., &quot;Overview of the 2002 IAB Network
                Management Workshop&quot;, <a href="https://tools.ietf.org/html/rfc3535">RFC 3535</a>, May 2003.

   [<a name="ref-RFC3629" id="ref-RFC3629">RFC3629</a>]    Yergeau, F., &quot;UTF-8, a transformation format of ISO
                10646&quot;, STD 63, <a href="https://tools.ietf.org/html/rfc3629">RFC 3629</a>, November 2003.

   [<a name="ref-RFC4251" id="ref-RFC4251">RFC4251</a>]    Ylonen, T. and C. Lonvick, &quot;The Secure Shell (SSH)
                Protocol Architecture&quot;, <a href="https://tools.ietf.org/html/rfc4251">RFC 4251</a>, January 2006.

   [<a name="ref-RFC4741" id="ref-RFC4741">RFC4741</a>]    Enns, R., &quot;NETCONF Configuration Protocol&quot;, <a href="https://tools.ietf.org/html/rfc4741">RFC 4741</a>,
                December 2006.

   [<a name="ref-RFC4742" id="ref-RFC4742">RFC4742</a>]    Wasserman, M. and T. Goddard, &quot;Using the NETCONF
                Configuration Protocol over Secure SHell (SSH)&quot;,
                <a href="https://tools.ietf.org/html/rfc4742">RFC 4742</a>, December 2006.

   [<a name="ref-RFC4743" id="ref-RFC4743">RFC4743</a>]    Goddard, T., &quot;Using NETCONF over the Simple Object
                Access Protocol (SOAP)&quot;, <a href="https://tools.ietf.org/html/rfc4743">RFC 4743</a>, December 2006.

   [<a name="ref-RFC4744" id="ref-RFC4744">RFC4744</a>]    Lear, E. and K. Crozier, &quot;Using the NETCONF Protocol
                over the Blocks Extensible Exchange Protocol (BEEP)&quot;,
                <a href="https://tools.ietf.org/html/rfc4744">RFC 4744</a>, December 2006.

   [<a name="ref-RFC5277" id="ref-RFC5277">RFC5277</a>]    Chisholm, S. and H. Trevino, &quot;NETCONF Event
                Notifications&quot;, <a href="https://tools.ietf.org/html/rfc5277">RFC 5277</a>, July 2008.



<span class="grey">Shafer                        Informational                    [Page 28]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-29" id="page-29" href="https://tools.ietf.org/html/rfc6244#page-29" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


   [<a name="ref-RFC5539" id="ref-RFC5539">RFC5539</a>]    Badra, M., &quot;NETCONF over Transport Layer Security
                (TLS)&quot;, <a href="https://tools.ietf.org/html/rfc5539">RFC 5539</a>, May 2009.

   [<a name="ref-RFC6020" id="ref-RFC6020">RFC6020</a>]    Bjorklund, M., &quot;YANG - A Data Modeling Language for the
                Network Configuration Protocol (NETCONF)&quot;, <a href="https://tools.ietf.org/html/rfc6020">RFC 6020</a>,
                October 2010.

   [<a name="ref-RFC6021" id="ref-RFC6021">RFC6021</a>]    Schoenwaelder, J., &quot;Common YANG Data Types&quot;, <a href="https://tools.ietf.org/html/rfc6021">RFC 6021</a>,
                October 2010.

   [<a name="ref-RFC6087" id="ref-RFC6087">RFC6087</a>]    Bierman, A., &quot;Guidelines for Authors and Reviewers of
                YANG Data Model Documents&quot;, <a href="https://tools.ietf.org/html/rfc6087">RFC 6087</a>, January 2011.

   [<a name="ref-RFC6110" id="ref-RFC6110">RFC6110</a>]    Lhotka, L., &quot;Mapping YANG to Document Schema Definition
                Languages and Validating NETCONF Content&quot;, <a href="https://tools.ietf.org/html/rfc6110">RFC 6110</a>,
                February 2011.

   [<a name="ref-RFC6243" id="ref-RFC6243">RFC6243</a>]    Bierman, A. and B. Lengyel, &quot;With-defaults Capability
                for NETCONF&quot;, <a href="https://tools.ietf.org/html/rfc6243">RFC 6243</a>, June 2011.

   [<a name="ref-SWEXPECT" id="ref-SWEXPECT">SWEXPECT</a>]   &quot;The Expect Home Page&quot;,
                &lt;<a href="http://expect.sourceforge.net/">http://expect.sourceforge.net/</a>&gt;.

   [<a name="ref-W3CXPATH" id="ref-W3CXPATH">W3CXPATH</a>]   DeRose, S. and J. Clark, &quot;XML Path Language (XPath)
                Version 1.0&quot;, World Wide Web Consortium
                Recommendation REC-xpath-19991116, November 1999,
                &lt;<a href="http://www.w3.org/TR/1999/REC-xpath-19991116">http://www.w3.org/TR/1999/REC-xpath-19991116</a>&gt;.

   [<a name="ref-W3CXQUERY" id="ref-W3CXQUERY">W3CXQUERY</a>]  Boag, S., &quot;XQuery 1.0: An XML Query Language&quot;, W3C
                WD WD-xquery-20050915, September 2005.

   [<a name="ref-W3CXSD" id="ref-W3CXSD">W3CXSD</a>]     Walmsley, P. and D. Fallside, &quot;XML Schema Part 0: Primer
                Second Edition&quot;, World Wide Web Consortium
                Recommendation REC-xmlschema-0-20041028, October 2004,
                &lt;<a href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028">http://www.w3.org/TR/2004/REC-xmlschema-0-20041028</a>&gt;.

   [<a name="ref-W3CXSLT" id="ref-W3CXSLT">W3CXSLT</a>]    Clark, J., &quot;XSL Transformations (XSLT) Version 1.0&quot;,
                World Wide Web Consortium Recommendation REC-xslt-
                19991116, November 1999,
                &lt;<a href="http://www.w3.org/TR/1999/REC-xslt-19991116">http://www.w3.org/TR/1999/REC-xslt-19991116</a>&gt;.

<span class="h3"><h3><a class="selflink" name="section-6.2" href="https://tools.ietf.org/html/rfc6244#section-6.2">6.2</a>. Informative References</h3></span>

   [<a name="ref-RCDML" id="ref-RCDML">RCDML</a>]      Presuhn, R., Ed., &quot;Requirements for a Configuration Data
                Modeling Language&quot;, Work in Progress, February 2008.






<span class="grey">Shafer                        Informational                    [Page 29]</span></pre> 
   <hr class="noprint" style="width: 96ex;" align="left" />
   <!--NewPage-->
   <pre class="newpage"><a name="page-30" id="page-30" href="https://tools.ietf.org/html/rfc6244#page-30" class="invisible"> </a>
<span class="grey"><a href="https://tools.ietf.org/html/rfc6244">RFC 6244</a>                       NETMODARCH                      June 2011</span>


Author's Address

   Phil Shafer
   Juniper Networks

   EMail: phil@juniper.net













































Shafer                        Informational                    [Page 30]

</pre>
   <br /> 
   <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.127, available from <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a> </small></small></span> 
  </div> 
 </body>
</html>